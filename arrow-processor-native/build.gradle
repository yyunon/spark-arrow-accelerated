import org.gradle.internal.jvm.Jvm

import static org.apache.tools.ant.taskdefs.condition.Os.*

plugins {
    id 'cpp-library'
}

Task generateHeaders = project(':arrow-processor').generateNativeHeaders

class LibFinder {

    def extension = isFamily(FAMILY_MAC) ? "dylib" : "so"

    def libPaths = {
        def paths = (System.getenv("LD_LIBRARY_PATH")?.split(':')?.toList() ?: [])
        paths.add ( "/usr/local/lib" )
        paths.add ( "/usr/local/lib64" )
        paths
    }()

    def call(String name) {
        File library = libPaths.collect { new File("$it/lib$name.$extension") }.find { it.exists() }
        if (library == null) {
            throw new GradleException("Cannot find library '$name'. Please add the directory containing the library to LD_LIBRARY_PATH.")
        }
        library.absolutePath
    }
}

Task generateProtobuf = task generateProtobuf(type: Exec) {

    def filename = "Types_.proto"
    inputs.files("$projectDir/$filename")

    outputs.dir("$project.buildDir/protobuf")

    commandLine "protoc"

    args('--proto_path', projectDir.absolutePath)
    args('--cpp_out', outputs.files[0].absolutePath)
    args(filename)
}

library {
    def findLib = new LibFinder();

    targetMachines = [
    machines.linux.x86_64
    ]
    if (isArch("ppc64le")){
        // Gradle cannot handle the power systems architecture automatically, therefore we tell them to use the classic linux toolChain
        //probably not the best/cleanest way to do it, but it seems to work
        targetMachines = [
            machines.linux.x86_64
        ]
    }

    def additionalIncludes = System.getenv("ADDITIONAL_INCLUDES")?.split(':')?.toList() ?:[]

    source.from(file('src/main/cpp'), generateProtobuf.outputs.files[0])
    privateHeaders.from (generateHeaders.outputs.files[0], generateProtobuf.outputs.files[0])

    binaries.configureEach {
        compileTask.get().dependsOn(generateHeaders)
        compileTask.get().dependsOn(generateProtobuf)

        compileTask.get().compilerArgs.add("-v")
        compileTask.get().compilerArgs.add("--std=c++11")
        compileTask.get().compilerArgs.add("-Wall")

        additionalIncludes.each {
            compileTask.get().includes(it)
        }
        compileTask.get().includes '/usr/local/include'

        compileTask.get().includes("${Jvm.current().javaHome}/include")

        if (isFamily(FAMILY_MAC)) {
            compileTask.get().includes("${Jvm.current().javaHome}/include/darwin")

            compileTask.get().toolChain.set(toolChains.withType(Clang)[0])
            compileTask.get().compilerArgs.add('-mmacosx-version-min=10.9')
            linkTask.get().linkerArgs.add('-mmacosx-version-min=10.9')
            linkTask.get().linkerArgs.add("--std=c++11")
            linkTask.get().toolChain.set(toolChains.withType(Clang)[0])

        } else {
            compileTask.get().includes("${Jvm.current().javaHome}/include/linux")
        }

        linkTask.get().lib(findLib("gandiva_jni"))
        linkTask.get().lib(findLib("protobuf"))
        linkTask.get().lib(findLib("arrow_dataset"))
        linkTask.get().lib(findLib("arrow"))
        linkTask.get().lib(findLib("fletcher"))
        linkTask.get().lib(findLib("fletcher_aws"))
        linkTask.get().lib(findLib("parquet"))
    }
}
