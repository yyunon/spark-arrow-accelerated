// Copyright 2018-2019 Delft University of Technology
//
// Licensed under the Apache License, Version 2.0 (the "License");
// you may not use this file except in compliance with the License.
// You may obtain a copy of the License at
//
//     http://www.apache.org/licenses/LICENSE-2.0
//
// Unless required by applicable law or agreed to in writing, software
// distributed under the License is distributed on an "AS IS" BASIS,
// WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
// See the License for the specific language governing permissions and
// limitations under the License.

#include "fletchgen/mmio.h"

#include <fletcher/fletcher.h>
#include <fletcher/common.h>
#include <cerata/api.h>
#include <memory>
#include <string>
#include <fstream>
#include <algorithm>

#include "fletchgen/axi4_lite.h"
#include "fletchgen/basic_types.h"

namespace fletchgen {

using cerata::vector;
using cerata::component;

static std::string ToString(MmioBehavior behavior) {
  switch (behavior) {
    case MmioBehavior::STATUS: return "status";
    case MmioBehavior::STROBE: return "strobe";
    default: return "control";
  }
}

static Port::Dir ToDir(MmioBehavior behavior) {
  switch (behavior) {
    case MmioBehavior::STATUS: return Port::Dir::IN;
    case MmioBehavior::STROBE: return Port::Dir::OUT;
    default: return Port::Dir::OUT;
  }
}

MmioPort::MmioPort(const std::string &name, Port::Dir dir, const MmioReg &reg,
                   const std::shared_ptr<ClockDomain> &domain) :
    Port(name, reg.width == 1 ? cerata::bit() : vector(reg.width), dir, domain), reg(reg) {}

std::shared_ptr<cerata::Object> MmioPort::Copy() const {
  return std::make_shared<MmioPort>(name(), dir_, reg, domain_);
}

std::shared_ptr<MmioPort> mmio_port(Port::Dir dir, const MmioReg &reg, const std::shared_ptr<ClockDomain> &domain) {
  return std::make_shared<MmioPort>(reg.name, dir, reg, domain);
}

std::shared_ptr<Component> mmio(const std::vector<fletcher::RecordBatchDescription> &batches,
                                const std::vector<MmioReg> &regs) {
  // Clock/reset port.
  // TODO(johanpel): Everything is on the kernel clock domain now until vhdmmio gets CDC support.
  auto kcd = port("kcd", cr(), Port::Dir::IN, kernel_cd());
  // Create the component.
  auto comp = component("mmio", {kcd});
  // Generate all ports and add to the component.
  for (const auto &reg : regs) {
    auto dir = ToDir(reg.behavior);
    auto port = mmio_port(dir, reg, kernel_cd());
    // Change the name to vhdmmio convention.
    port->SetName("f_" + reg.name + (std::string(dir == Port::Dir::IN ? "_write" : "") + "_data"));
    comp->Add(port);
  }
  // Add the bus interface.
  auto bus = axi4_lite(Port::Dir::IN, bus_cd());
  comp->Add(bus);

  // This will be a primitive component generated by vhdmmio.
  comp->SetMeta(cerata::vhdl::meta::PRIMITIVE, "true");
  comp->SetMeta(cerata::vhdl::meta::LIBRARY, "work");
  comp->SetMeta(cerata::vhdl::meta::PACKAGE, "mmio_pkg");

  return comp;
}

static size_t AddrSpaceUsed(uint32_t width) {
  return 4 * (width / 32 + (width % 32 != 0));
}

std::string GenerateVhdmmioYaml(const std::vector<std::vector<MmioReg> *>& regs, std::optional<size_t *> next_addr) {
  std::stringstream ss;
  // The next free byte address.
  size_t next_free_addr = 0;
  // Header:
  ss << "metadata:\n"
        "  name: mmio\n"
        "  doc: Fletchgen generated MMIO configuration.\n"
        "  \n"
        "entity:\n"
        "  bus-flatten:  yes\n"
        "  bus-prefix:   mmio_\n"
        "  clock-name:   kcd_clk\n"
        "  reset-name:   kcd_reset\n"
        "\n"
        "features:\n"
        "  bus-width:    32\n"
        "  optimize:     yes\n"
        "\n"
        "interface:\n"
        "  flatten:      yes\n"
        "\n"
        "fields: \n";

  // Iterate over the registers and generate the appropriate YAML lines.
  for (auto &sub : regs) {
    for (auto &r : *sub) {
      // Determine the address.
      if (r.addr) {
        // There is a fixed address.
        ss << "  - address: " << *r.addr << "\n";
        // Just take this address plus its space as the next address. This limits how the vector of MmioRegs can be
        // supplied (fixed addr. must be at the start of the vector and ordered), but we don't currently use this in
        // any other way.
        next_free_addr = *r.addr + AddrSpaceUsed(r.width);
      } else {
        // There is not a fixed address.
        ss << "  - address: " << next_free_addr << "\n";
        r.addr = next_free_addr;
        next_free_addr += AddrSpaceUsed(r.width);
      }
      // Set doc, name and other stuff.
      ss << "    name: " << r.name << "\n";
      if (!r.desc.empty()) {
        ss << "    doc: " << r.desc << "\n";
      }
      if (r.width > 1) {
        ss << "    bitrange: " << r.index + r.width - 1 << ".." << r.index << "\n";
      } else {
        ss << "    bitrange: " << r.index << "\n";
      }
      ss << "    behavior: " << ToString(r.behavior) << "\n";
      ss << "\n";
    }
  }

  if (next_addr) {
    **next_addr = next_free_addr;
  }

  return ss.str();
}

bool ExposeToKernel(MmioFunction fun) {
  switch (fun) {
    case MmioFunction::DEFAULT: return true;
    case MmioFunction::KERNEL: return true;
    case MmioFunction::BATCH: return true;
    default:return false;
  }
}

}  // namespace fletchgen
